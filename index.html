<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=3840, height=2160">
    <title>è°¢æ—éš”ç¦»æ¨¡å‹ - 4Käº¤äº’å¼ä»¿çœŸ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 3840px;
            height: 2160px;
            overflow: hidden;
        }
        
        body {
            font-family: 'Microsoft YaHei', 'PingFang SC', 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            display: flex;
            padding: 40px;
            gap: 40px;
        }
        
        /* å·¦ä¾§çŸ©é˜µåŒºåŸŸ - å 3/5 */
        .left-panel {
            width: 60%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(145deg, #8B0000 0%, #6B0000 100%);
            border-radius: 24px;
            padding: 40px;
            box-shadow: 0 20px 80px rgba(0,0,0,0.5);
        }
        
        .matrix-title {
            color: white;
            font-size: 52px;
            font-weight: bold;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .grid-wrapper {
            background: #F5F5DC;
            padding: 16px;
            border-radius: 16px;
            box-shadow: inset 0 4px 20px rgba(0,0,0,0.2);
        }
        
        #grid {
            display: grid;
            gap: 0;
        }
        
        .cell {
            transition: background-color 0.05s;
        }
        
        /* å³ä¾§æ§åˆ¶é¢æ¿åŒºåŸŸ - å 2/5 */
        .right-panel {
            width: 40%;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 28px;
        }
        
        /* æ ‡é¢˜åŒº */
        .header-section {
            background: linear-gradient(145deg, #8B0000 0%, #6B0000 100%);
            border-radius: 24px;
            padding: 50px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
        }
        
        .header-section h1 {
            color: white;
            font-size: 72px;
            font-weight: bold;
            margin-bottom: 20px;
        }
        
        .header-section .subtitle {
            color: #e0e0e0;
            font-size: 32px;
        }
        
        /* æ§åˆ¶é¢æ¿ */
        .control-section {
            background: linear-gradient(145deg, #2d2d44 0%, #1e1e2e 100%);
            border-radius: 24px;
            padding: 50px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
        }
        
        .control-title {
            color: #FFD700;
            font-size: 42px;
            font-weight: bold;
            margin-bottom: 36px;
        }
        
        .threshold-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        
        .threshold-label {
            color: white;
            font-size: 36px;
        }
        
        .threshold-value {
            color: #FFD700;
            font-size: 64px;
            font-weight: bold;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 24px;
        }
        
        .slider-btn {
            background: linear-gradient(145deg, #4a4a6a, #3a3a5a);
            color: white;
            border: none;
            width: 90px;
            height: 90px;
            border-radius: 16px;
            font-size: 48px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .slider-btn:hover {
            background: linear-gradient(145deg, #5a5a7a, #4a4a6a);
            transform: translateY(-2px);
        }
        
        .slider-btn:active {
            transform: translateY(0);
        }
        
        input[type="range"] {
            flex: 1;
            height: 20px;
            border-radius: 10px;
            background: #555;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(145deg, #5a9ade, #3a7abe);
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        
        /* æŒ‰é’®åŒº */
        .buttons-section {
            display: flex;
            gap: 24px;
        }
        
        .btn {
            flex: 1;
            padding: 36px 24px;
            border: none;
            border-radius: 20px;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            color: white;
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-run {
            background: linear-gradient(145deg, #22c55e, #16a34a);
        }
        
        .btn-run.running {
            background: linear-gradient(145deg, #eab308, #ca8a04);
        }
        
        .btn-step {
            background: linear-gradient(145deg, #3b82f6, #2563eb);
        }
        
        .btn-reset {
            background: linear-gradient(145deg, #ef4444, #dc2626);
        }
        
        /* ç»Ÿè®¡é¢æ¿ */
        .stats-section {
            background: linear-gradient(145deg, #2d2d44 0%, #1e1e2e 100%);
            border-radius: 24px;
            padding: 50px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            flex: 1;
        }
        
        .stats-title {
            color: #4ade80;
            font-size: 42px;
            font-weight: bold;
            margin-bottom: 36px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 36px;
            height: calc(100% - 80px);
        }
        
        .stat-card {
            background: linear-gradient(145deg, #3a3a5a, #2a2a4a);
            border-radius: 20px;
            padding: 36px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .stat-label {
            color: #aaa;
            font-size: 32px;
            margin-bottom: 16px;
        }
        
        .stat-value {
            color: white;
            font-size: 64px;
            font-weight: bold;
        }
        
        .stat-value.yellow {
            color: #FFD700;
        }
        
        .stat-value.green {
            color: #4ade80;
        }
        
        .stat-value.cyan {
            color: #22d3ee;
        }
        
        /* å›¾ä¾‹ */
        .legend-section {
            background: linear-gradient(145deg, #2d2d44 0%, #1e1e2e 100%);
            border-radius: 24px;
            padding: 40px 50px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
        }
        
        .legend-row {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .legend-color {
            width: 50px;
            height: 50px;
            border-radius: 10px;
        }
        
        .legend-color.red {
            background: #DC2626;
        }
        
        .legend-color.blue {
            background: #1E3A5F;
        }
        
        .legend-color.empty {
            background: #F5F5DC;
            border: 2px solid #999;
        }
        
        .legend-text {
            color: white;
            font-size: 34px;
        }
        
        /* è¯´æ˜é¢æ¿ - ç¼©å°é«˜åº¦ */
        .info-section {
            background: linear-gradient(145deg, #FFFACD 0%, #F5F5DC 100%);
            border-radius: 24px;
            padding: 40px 50px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .info-title {
            color: #333;
            font-size: 40px;
            font-weight: bold;
            margin-bottom: 24px;
        }
        
        .info-content {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            flex: 1;
        }
        
        .info-text {
            color: #333;
            font-size: 34px;
            line-height: 1.7;
        }
        
        .info-highlight {
            background: rgba(139, 0, 0, 0.12);
            padding: 28px 32px;
            border-radius: 16px;
            border-left: 8px solid #8B0000;
            margin-top: 20px;
        }
        
        .info-highlight p {
            color: #6B0000;
            font-size: 32px;
            font-weight: 600;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <!-- å·¦ä¾§çŸ©é˜µåŒºåŸŸ -->
    <div class="left-panel">
        <div class="matrix-title">ç©ºé—´åˆ†å¸ƒæ¼”åŒ– (200 Ã— 200)</div>
        <div class="grid-wrapper">
            <div id="grid"></div>
        </div>
    </div>
    
    <!-- å³ä¾§æ§åˆ¶é¢æ¿åŒºåŸŸ -->
    <div class="right-panel">
        <!-- æ ‡é¢˜ -->
        <div class="header-section">
            <h1>è°¢æ—éš”ç¦»æ¨¡å‹</h1>
            <p class="subtitle">Schelling Segregation Model</p>
        </div>
        
        <!-- æ§åˆ¶é¢æ¿ -->
        <div class="control-section">
            <div class="control-title">âš™ï¸ å‚æ•°æ§åˆ¶</div>
            <div class="threshold-row">
                <span class="threshold-label">åŒç§æ—é‚»å±…åå¥½é˜ˆå€¼</span>
                <span class="threshold-value" id="thresholdDisplay">50%</span>
            </div>
            <div class="slider-container">
                <button class="slider-btn" onclick="adjustThreshold(-5)">âˆ’</button>
                <input type="range" id="threshold" min="0" max="100" value="50" oninput="updateThreshold(this.value)">
                <button class="slider-btn" onclick="adjustThreshold(5)">+</button>
            </div>
        </div>
        
        <!-- æ§åˆ¶æŒ‰é’® -->
        <div class="buttons-section">
            <button class="btn btn-run" id="runBtn" onclick="toggleRun()">â–¶ è¿è¡Œ</button>
            <button class="btn btn-step" onclick="singleStep()">â­ å•æ­¥</button>
            <button class="btn btn-reset" onclick="resetGrid()">ğŸ”„ é‡ç½®</button>
        </div>
        
        <!-- å®æ—¶ç»Ÿè®¡ -->
        <div class="stats-section">
            <div class="stats-title">ğŸ“Š å®æ—¶ç»Ÿè®¡</div>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">è¿­ä»£æ­¥æ•°</div>
                    <div class="stat-value cyan" id="steps">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">è¿è¡Œæ—¶é—´</div>
                    <div class="stat-value" id="time">0.0ç§’</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">ä¸æ»¡æ„ä½æˆ·</div>
                    <div class="stat-value yellow" id="unhappy">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">éš”ç¦»æŒ‡æ•°</div>
                    <div class="stat-value green" id="segregation">0%</div>
                </div>
            </div>
        </div>
        
        <!-- å›¾ä¾‹ -->
        <div class="legend-section">
            <div class="legend-row">
                <div class="legend-item">
                    <div class="legend-color red"></div>
                    <span class="legend-text">ç¾¤ä½“ A</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color blue"></div>
                    <span class="legend-text">ç¾¤ä½“ B</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color empty"></div>
                    <span class="legend-text">ç©ºç½®å•å…ƒ</span>
                </div>
            </div>
        </div>
        
        <!-- æ¨¡å‹è¯´æ˜ -->
        <div class="info-section">
            <div class="info-title">ğŸ“– æ¨¡å‹è¯´æ˜</div>
            <div class="info-content">
                <p class="info-text">
                    è°¢æ—éš”ç¦»æ¨¡å‹ç”±è¯ºè´å°”ç»æµå­¦å¥–å¾—ä¸»Thomas Schellingäº1971å¹´æå‡ºã€‚æ¯ä¸ªæ™ºèƒ½ä½“æ£€è§†å…¶Mooreé‚»åŸŸå†…åŒç±»å æ¯”ï¼Œè‹¥ä½äºåå¥½é˜ˆå€¼åˆ™éšæœºè¿ç§»ã€‚
                </p>
                <div class="info-highlight">
                    <p>æ ¸å¿ƒå‘ç°ï¼šå³ä½¿30%çš„æ¸©å’Œåå¥½ï¼Œç³»ç»Ÿä»å°†æ¼”åŒ–ä¸ºé«˜åº¦éš”ç¦»æ ¼å±€ã€‚</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // é…ç½®å‚æ•° - 200x200çŸ©é˜µ
        const GRID_SIZE = 200;
        const CELL_SIZE = 9;
        const EMPTY_RATIO = 0.1;
        
        // é€Ÿåº¦æ§åˆ¶å‚æ•°
        const FRAME_INTERVAL = 80;      // å¸§é—´éš”(ms)ï¼Œè¶Šå¤§è¶Šæ…¢
        const MOVES_PER_STEP = 0.15;    // æ¯æ­¥ç§»åŠ¨çš„ä¸æ»¡æ„ä½æˆ·æ¯”ä¾‹ï¼Œè¶Šå°è¶Šæ…¢
        const MIN_MOVES = 5;            // æ¯æ­¥æœ€å°‘ç§»åŠ¨æ•°é‡
        
        // çŠ¶æ€å˜é‡
        let grid = [];
        let threshold = 0.5;
        let isRunning = false;
        let steps = 0;
        let startTime = null;
        let animationId = null;
        let timerInterval = null;
        
        // Canvas
        let canvas, ctx;
        
        // åˆå§‹åŒ–Canvas
        function initCanvas() {
            const gridEl = document.getElementById('grid');
            gridEl.innerHTML = '';
            
            canvas = document.createElement('canvas');
            canvas.width = GRID_SIZE * CELL_SIZE;
            canvas.height = GRID_SIZE * CELL_SIZE;
            canvas.style.display = 'block';
            gridEl.appendChild(canvas);
            ctx = canvas.getContext('2d');
        }
        
        // åˆå§‹åŒ–ç½‘æ ¼æ•°æ®
        function initGrid() {
            grid = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                const row = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    const rand = Math.random();
                    if (rand < EMPTY_RATIO) {
                        row.push(0);
                    } else if (rand < (1 + EMPTY_RATIO) / 2) {
                        row.push(1);
                    } else {
                        row.push(2);
                    }
                }
                grid.push(row);
            }
        }
        
        // æ¸²æŸ“æ•´ä¸ªç½‘æ ¼
        function renderGrid() {
            const imageData = ctx.createImageData(GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);
            const data = imageData.data;
            
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const color = getCellColorRGB(grid[i][j]);
                    
                    for (let dy = 0; dy < CELL_SIZE; dy++) {
                        for (let dx = 0; dx < CELL_SIZE; dx++) {
                            const px = j * CELL_SIZE + dx;
                            const py = i * CELL_SIZE + dy;
                            const idx = (py * GRID_SIZE * CELL_SIZE + px) * 4;
                            
                            data[idx] = color.r;
                            data[idx + 1] = color.g;
                            data[idx + 2] = color.b;
                            data[idx + 3] = 255;
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // è·å–RGBé¢œè‰²
        function getCellColorRGB(value) {
            switch (value) {
                case 1: return { r: 220, g: 38, b: 38 };
                case 2: return { r: 30, g: 58, b: 95 };
                default: return { r: 245, g: 245, b: 220 };
            }
        }
        
        // è®¡ç®—åŒç±»é‚»å±…æ¯”ä¾‹
        function getSameTypeRatio(row, col) {
            const type = grid[row][col];
            if (type === 0) return 1;
            
            let sameCount = 0;
            let totalNeighbors = 0;
            
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const newRow = row + i;
                    const newCol = col + j;
                    if (newRow >= 0 && newRow < GRID_SIZE && newCol >= 0 && newCol < GRID_SIZE) {
                        const neighbor = grid[newRow][newCol];
                        if (neighbor !== 0) {
                            totalNeighbors++;
                            if (neighbor === type) {
                                sameCount++;
                            }
                        }
                    }
                }
            }
            
            return totalNeighbors === 0 ? 1 : sameCount / totalNeighbors;
        }
        
        // è®¡ç®—ç»Ÿè®¡æŒ‡æ ‡
        function calculateMetrics() {
            let unhappy = 0;
            let totalSameRatio = 0;
            let agentCount = 0;
            
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j] !== 0) {
                        const ratio = getSameTypeRatio(i, j);
                        totalSameRatio += ratio;
                        agentCount++;
                        if (ratio < threshold) {
                            unhappy++;
                        }
                    }
                }
            }
            
            document.getElementById('unhappy').textContent = unhappy.toLocaleString();
            document.getElementById('segregation').textContent = 
                (agentCount > 0 ? (totalSameRatio / agentCount * 100).toFixed(1) : 0) + '%';
            
            return unhappy;
        }
        
        // æ‰¾åˆ°æ‰€æœ‰ç©ºä½
        function findEmptyCells() {
            const emptyCells = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j] === 0) {
                        emptyCells.push({ row: i, col: j });
                    }
                }
            }
            return emptyCells;
        }
        
        // æ‰§è¡Œä¸€æ­¥æ¨¡æ‹Ÿ
        function simulateStep() {
            const emptyCells = findEmptyCells();
            if (emptyCells.length === 0) return false;
            
            const unhappyAgents = [];
            
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j] !== 0) {
                        const ratio = getSameTypeRatio(i, j);
                        if (ratio < threshold) {
                            unhappyAgents.push({ row: i, col: j, type: grid[i][j] });
                        }
                    }
                }
            }
            
            if (unhappyAgents.length === 0) return false;
            
            // Fisher-Yates æ´—ç‰Œ
            for (let i = unhappyAgents.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [unhappyAgents[i], unhappyAgents[j]] = [unhappyAgents[j], unhappyAgents[i]];
            }
            
            // å‡æ…¢æ”¶æ•›é€Ÿåº¦ï¼šæ¯æ­¥åªç§»åŠ¨è¾ƒå°‘çš„æ™ºèƒ½ä½“
            const movedCount = Math.min(
                unhappyAgents.length, 
                Math.max(MIN_MOVES, Math.floor(unhappyAgents.length * MOVES_PER_STEP))
            );
            const availableEmpty = [...emptyCells];
            
            for (let i = 0; i < movedCount && availableEmpty.length > 0; i++) {
                const agent = unhappyAgents[i];
                const emptyIndex = Math.floor(Math.random() * availableEmpty.length);
                const emptyCell = availableEmpty[emptyIndex];
                
                grid[emptyCell.row][emptyCell.col] = agent.type;
                grid[agent.row][agent.col] = 0;
                
                availableEmpty.splice(emptyIndex, 1);
                availableEmpty.push({ row: agent.row, col: agent.col });
            }
            
            steps++;
            document.getElementById('steps').textContent = steps.toLocaleString();
            
            return unhappyAgents.length > 0;
        }
        
        // åˆ‡æ¢è¿è¡ŒçŠ¶æ€
        function toggleRun() {
            isRunning = !isRunning;
            const btn = document.getElementById('runBtn');
            
            if (isRunning) {
                btn.textContent = 'â¸ æš‚åœ';
                btn.classList.add('running');
                if (!startTime) {
                    startTime = Date.now();
                }
                timerInterval = setInterval(updateTimer, 100);
                runSimulation();
            } else {
                btn.textContent = 'â–¶ è¿è¡Œ';
                btn.classList.remove('running');
                if (animationId) {
                    clearTimeout(animationId);
                }
                if (timerInterval) {
                    clearInterval(timerInterval);
                }
            }
        }
        
        // è¿è¡Œæ¨¡æ‹Ÿå¾ªç¯ - ä½¿ç”¨setTimeoutæ§åˆ¶é€Ÿåº¦
        function runSimulation() {
            if (!isRunning) return;
            
            const hasUnhappy = simulateStep();
            if (!hasUnhappy) {
                isRunning = false;
                const btn = document.getElementById('runBtn');
                btn.textContent = 'â–¶ è¿è¡Œ';
                btn.classList.remove('running');
                if (timerInterval) {
                    clearInterval(timerInterval);
                }
                renderGrid();
                calculateMetrics();
                return;
            }
            
            renderGrid();
            calculateMetrics();
            
            // ä½¿ç”¨setTimeoutæ§åˆ¶å¸§ç‡ï¼Œå®ç°æ›´æ…¢çš„è¿­ä»£é€Ÿåº¦
            animationId = setTimeout(runSimulation, FRAME_INTERVAL);
        }
        
        // æ›´æ–°è®¡æ—¶å™¨
        function updateTimer() {
            if (startTime) {
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                document.getElementById('time').textContent = elapsed + 'ç§’';
            }
        }
        
        // å•æ­¥æ‰§è¡Œ
        function singleStep() {
            if (isRunning) {
                toggleRun();
            }
            if (!startTime) {
                startTime = Date.now();
            }
            simulateStep();
            renderGrid();
            calculateMetrics();
            updateTimer();
        }
        
        // é‡ç½®ç½‘æ ¼
        function resetGrid() {
            if (isRunning) {
                toggleRun();
            }
            initGrid();
            renderGrid();
            steps = 0;
            startTime = null;
            document.getElementById('steps').textContent = '0';
            document.getElementById('time').textContent = '0.0ç§’';
            calculateMetrics();
        }
        
        // æ›´æ–°é˜ˆå€¼
        function updateThreshold(value) {
            threshold = value / 100;
            document.getElementById('thresholdDisplay').textContent = value + '%';
            document.getElementById('threshold').value = value;
            calculateMetrics();
        }
        
        // è°ƒæ•´é˜ˆå€¼
        function adjustThreshold(delta) {
            let newValue = Math.round(threshold * 100) + delta;
            newValue = Math.max(0, Math.min(100, newValue));
            updateThreshold(newValue);
        }
        
        // åˆå§‹åŒ–
        window.onload = function() {
            initCanvas();
            initGrid();
            renderGrid();
            calculateMetrics();
        };
    </script>
</body>
</html>
